--소문자로 처리
select first_name, lower(first_name)
from employees;
--대문자로 처리
select first_name, upper(first_name)
from employees;
--sumstr(XXX, X,Y): X번째부터 Y개수만큼 출력
select phone_number,
substr(phone_number,1,3),
substr(phone_number,1,(instr(phone_number,'.')-1))
from employees;

select sysdate from dual;
select COUNT(*), count(department_id) from employees;
select sum(salary), round(avg(salary),4), max(salary), min(salary) from employees;
select department_id, sum(salary),round(avg(salary),4)
from employees
group by department_id--그륩별로 계산
having avg(salary)>10000--연산이 가능한 where
ORDER by department_id;

select department_id , sum(salary)
from employees
GROUP BY department_id
union
select null, sum(salary)
from employees;

select department_id , sum(salary)
from employees
GROUP BY ROLLUP (department_id);

select department_id ,job_id,sum(salary), round(avg(salary),3)
from employees
GROUP BY department_id,rollup (job_id);

select department_id ,job_id,sum(salary), GrOUPING(department_id),GrOUPING(job_id)
from employees
GROUP by rollup(department_id,job_id);

select department_id, salary,rank() over(order by salary DESC)
from employees;

--join
--oracle 문법
select employee_id, department_name
from employees, departments
where employees.department_id=departments.DEPARTMENT_ID;
--등가조인(EQUI join)
--oracle 문법
--별칭사용시 테이블명으로 컬럼에 접근하면 에러
select employee_id, department_name
from employees e, departments d
where e.department_id=d.DEPARTMENT_ID
order by 1;
--ANSI문법
select employee_id, department_name
from employees e join departments d
on (e.department_id=d.DEPARTMENT_ID)
order by 1;

--순환참조 (self join)
--employee_id email manager_id, 매니져의이메일 출력
SELECT e1.employee_id, e1.email, e1.manager_id, e2.email
from employees e1 join employees e2
on (e1.manager_id=e2.employee_id)
order by 1;

--outer join
--Oracle
--(+)가 없는것이 출력대상
--출력대상에 (+)있는 테이블을 출력, 등가조건이 부합하지 않으면 null로 출력
select e.employee_id, e.email, e.department_id, d.department_name
from EMPLOYEES e, departments d
where e.department_id=d.department_id(+);
select e.employee_id, e.email, e.department_id, d.department_name
from EMPLOYEES e, departments d
where e.department_id(+)=d.department_id;
--ANSI
--left (outer) join : 출력대상이 등가조건에 부합하더라도 왼쪽테이블 정보는 모두출력
--오른쪽테이블정보 null로 출력
select e.employee_id, e.email, e.department_id, d.department_name
from EMPLOYEES e left join departments d
on(e.department_id=d.department_id);
--right (outer) join : 출력대상이 등가조건에 부합하더라도 오른쪽테이블 정보는 모두출력
--왼쪽테이블정보 null로 출력
select e.employee_id, e.email, e.department_id, d.department_name
from EMPLOYEES e right join departments d
on(e.department_id=d.department_id);

--full join
--Oracle 문법
select e.employee_id, e.email, e.department_id, d.department_name
from EMPLOYEES e, departments d
where e.department_id=d.department_id(+)
UNION
select e.employee_id, e.email, e.department_id, d.department_name
from EMPLOYEES e, departments d
where e.department_id(+)=d.department_id;
--ANSI
select e.employee_id, e.email, e.department_id, d.department_name
from EMPLOYEES e full join departments d
on(e.department_id=d.department_id);

--cross join
--ansi 문법
select employee_id, department_name
from employees cross join departments;
--카티션 곱의 결과가 나온다.
